import os
import time
import uuid
import traceback
from fastapi import HTTPException
from datetime import datetime
from sqlalchemy import REAL, create_engine, Column, Integer, String, Text, ForeignKey, asc, JSON, text
from sqlalchemy.orm import sessionmaker, declarative_base, relationship, Session

# --- This part remains the same ---
APP_DATA_DIR = os.path.join(os.path.expanduser('~'), '.dreamtester_2.0')

os.makedirs(APP_DATA_DIR, exist_ok=True)

DATABASE_URL = f"sqlite:///{os.path.join(APP_DATA_DIR, 'database.db')}"

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False, "timeout": 30})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()

# --- ApiKey Model remains the same ---
class ApiKey(Base):
    __tablename__ = "api_keys"
    id = Column(Integer, primary_key=True, index=True)
    exchange_name = Column(String, unique=True, index=True)
    api_key = Column(String)
    api_secret = Column(String)

# --- NEW: Define the StrategyFile Model ---
class StrategyFile(Base):
    __tablename__ = "strategy_files"

    # The frontend uses UUIDs, so we'll use a String primary key
    id = Column(String, primary_key=True, index=True)
    name = Column(String, index=True)
    type = Column(String) # 'file' or 'folder'
    content = Column(Text, nullable=True) # Content is only for files

    # Self-referencing foreign key for hierarchy
    parent_id = Column(String, ForeignKey("strategy_files.id"), nullable=True)
    
    # Relationship to easily access children from a parent
    children = relationship("StrategyFile", back_populates="parent", cascade="all, delete-orphan")
    parent = relationship("StrategyFile", back_populates="children", remote_side=[id])

    # Convert model instance to a dictionary, matching frontend's expected structure
    def to_dict(self):
        sorted_children = sorted(self.children, key=lambda child: child.name.lower())
        return {
            "id": self.id,
            "name": self.name,
            "type": self.type,
            "content": self.content,
            "children": [child.to_dict() for child in sorted_children]
        }

class BacktestJob(Base):
    __tablename__ = "backtest_jobs"

    # We use the batch_id from the API endpoint as the primary key
    id = Column(String, primary_key=True, index=True) 
    
    # New columns to track the job's progress and outcome
    status = Column(String, default="pending") # "pending", "running", "completed", "failed"
    error_message = Column(Text, nullable=True) 
    logs = Column(JSON, nullable=True, default=lambda: []) # Default to an empty list
    
    # This still holds the final, successful result payload
    results_data = Column(JSON, nullable=True)
    
    created_at = Column(REAL, default=time.time)
    updated_at = Column(REAL, default=time.time, onupdate=time.time)


class LabelingTemplate(Base):
    __tablename__ = "labeling_templates"

    # The unique key generated by the frontend (e.g., custom_my_template_12345)
    key = Column(String, primary_key=True, index=True)
    
    # The user-friendly name (e.g., "My Template")
    name = Column(String, index=True)
    
    description = Column(String)
    
    # The actual Python code for the template
    code = Column(Text)

# It's identical in structure to the LabelingTemplate model.
class FeatureEngineeringTemplate(Base):
    __tablename__ = "feature_engineering_templates"

    key = Column(String, primary_key=True, index=True)
    name = Column(String, index=True)
    description = Column(String)
    code = Column(Text)

class BacktestTemplate(Base):
    """Stores user-saved custom backtest strategy templates for the pipeline."""
    __tablename__ = "backtest_templates"
    key = Column(String, primary_key=True, index=True)
    name = Column(String, index=True)
    description = Column(String)
    code = Column(Text)

# --- Create all tables in the database ---
# This will now only create api_keys, strategy_files, and backtest_jobs tables.
Base.metadata.create_all(bind=engine)



# --- CRUD functions for ApiKey remain the same ---
def save_api_key(exchange: str, key: str, secret: str):
    db = SessionLocal()
    try:
        db_key = db.query(ApiKey).filter(ApiKey.exchange_name == exchange).first()
        if db_key:
            db_key.api_key = key
            db_key.api_secret = secret
        else:
            db_key = ApiKey(exchange_name=exchange, api_key=key, api_secret=secret)
            db.add(db_key)
        
        db.commit()
        db.refresh(db_key)
        return {"status": "success", "message": f"{exchange.capitalize()} keys saved."}
    finally:
        db.close()

def get_api_key(exchange: str):
    db = SessionLocal()
    try:
        db_key = db.query(ApiKey).filter(ApiKey.exchange_name == exchange).first()
        if db_key:
            return {"exchange": db_key.exchange_name, "api_key": db_key.api_key, "api_secret": db_key.api_secret}
        return None
    finally:
        db.close()

# --- NEW: CRUD functions for Strategy Files ---

def get_strategies_tree():
    db = SessionLocal()
    try:
        
        # 1. Look for a root-level folder named "Portfolio"
        portfolio_folder = db.query(StrategyFile).filter(
            StrategyFile.name == "PORTFOLIO",
            StrategyFile.type == "folder",
            StrategyFile.parent_id == None
        ).first()
        
        # 2. If it doesn't exist, create it and a default file
        if not portfolio_folder:
            print("INFO: 'PORTFOLIO' folder not found. Creating it with a default template.")
            
            # Create the folder object
            new_portfolio_folder = StrategyFile(
                # You'll need a way to generate IDs, e.g., using uuid
                id=str(uuid.uuid4()), 
                name="PORTFOLIO",
                type="folder"
            )
            db.add(new_portfolio_folder)
            
            # Use db.flush() to send the SQL to the DB and assign an ID to our new folder object
            # This is crucial so we can use its ID as the parent_id for the child file.
            db.flush()
            
            # Define the content for the default portfolio template
            # Path to the default template file, assuming this script is in a 'backend' folder
            # and the template is in a sibling 'core' folder.
            template_path = os.path.join(os.path.dirname(__file__), 'core', 'portfolio.py')
            
            try:
                with open(template_path, 'r') as f:
                    default_portfolio_code = f.read()
            except FileNotFoundError:
                print(f"ERROR: Default portfolio template not found at {template_path}. Using a fallback.")
                # Fallback to the original hardcoded string if the file is missing
                default_portfolio_code = """"""
            
            # Create the default file, linking it to the new folder
            default_file = StrategyFile(
                id=str(uuid.uuid4()),
                name="Default_Portfolio.py",
                type="file",
                content=default_portfolio_code,
                parent_id=new_portfolio_folder.id # Link to the folder we just created
            )
            db.add(default_file)
            
            # Commit the transaction to save both the folder and the file
            db.commit()
            print("INFO: Successfully created 'Portfolio' folder and default template.")
        
        # Fetch only top-level items (those without a parent)
        top_level_items = db.query(StrategyFile).filter(StrategyFile.parent_id == None).order_by(asc(StrategyFile.name)).all()
        # The to_dict method will recursively build the rest of the tree
        return [item.to_dict() for item in top_level_items]
    finally:
        db.close()

def create_strategy_item(item_id: str, name: str, type: str, content: str = None, parent_id: str = None):
    db = SessionLocal()
    try:
        new_item = StrategyFile(id=item_id, name=name, type=type, content=content, parent_id=parent_id)
        db.add(new_item)
        db.commit()
        db.refresh(new_item)
        return new_item.to_dict()
    finally:
        db.close()

def update_strategy_item(item_id: str, name: str = None, content: str = None):
    db = SessionLocal()
    try:
        item_to_update = db.query(StrategyFile).filter(StrategyFile.id == item_id).first()
        if not item_to_update:
            return None
        if name is not None:
            item_to_update.name = name
        if content is not None:
            item_to_update.content = content
        db.commit()
        db.refresh(item_to_update)
        return item_to_update.to_dict()
    finally:
        db.close()
        
def delete_strategy_item(item_id: str):
    db = SessionLocal()
    try:
        item_to_delete = db.query(StrategyFile).filter(StrategyFile.id == item_id).first()
        
        if not item_to_delete:
            raise HTTPException(status_code=404, detail="Item not found.")
        
        # # Check if the item is a folder, is named "Portfolio", and is a root item.
        # if (item_to_delete.type == "folder" and 
        #     item_to_delete.name == "PORTFOLIO" and 
        #     item_to_delete.parent_id is None):
            
        #     # If it is, raise a 403 Forbidden error immediately.
        #     raise HTTPException(status_code=403, detail="The 'PORTFOLIO' folder is protected and cannot be deleted.")
        
        db.delete(item_to_delete)
        db.commit()
        return {"status": "success", "message": "Item deleted."}
    finally:
        db.close()
        
def move_strategy_item(item_id: str, new_parent_id: str | None):
    db = SessionLocal()
    try:
        item_to_move = db.query(StrategyFile).filter(StrategyFile.id == item_id).first()
        if not item_to_move:
            return None # Item not found
        
        # Prevent dropping a folder into itself or its own children (complex check, omitted for brevity but good for a real app)

        item_to_move.parent_id = new_parent_id
        db.commit()
        db.refresh(item_to_move)
        return {"status": "success", "message": "Item moved."}
    finally:
        db.close()
        
def clear_all_strategies():
    """
    Deletes all root-level files and folders EXCEPT for the 'Portfolio' folder.
    Relies on cascading deletes to remove children of the deleted folders.
    """
    db = SessionLocal()
    try:
        # --- Step 1: Find the protected 'Portfolio' folder ---
        portfolio_folder = db.query(StrategyFile).filter(
            StrategyFile.name == "PORTFOLIO",
            StrategyFile.type == "folder",
            StrategyFile.parent_id == None
        ).first()

        if not portfolio_folder:
            # Fallback behavior if the portfolio folder is missing.
            print("WARNING: 'PORTFOLIO' folder not found during clear_all. Clearing all items.")
            num_rows_deleted = db.query(StrategyFile).delete(synchronize_session=False)
        else:
            # --- Step 2: Delete all ROOT-LEVEL items that are NOT the portfolio folder ---
            # By adding `StrategyFile.parent_id == None`, we only target top-level items.
            # The cascade rule will handle deleting the children of these top-level folders.
            
            items_to_delete = db.query(StrategyFile).filter(
                StrategyFile.parent_id == None,
                StrategyFile.id != portfolio_folder.id
            )
            
            # We need to count before deleting as the query object is consumed.
            num_items_to_delete = items_to_delete.count()
            
            if num_items_to_delete > 0:
                items_to_delete.delete(synchronize_session=False)
                # Note: The returned count from .delete() might reflect more than just the root
                # items if the cascade is complex. We'll return the root count for clarity.
            
        db.commit()
        # Using the count of root items deleted for a clearer message.
        return {"status": "success", "message": f"Successfully cleared {num_items_to_delete} root items."}
    
    except Exception as e:
        db.rollback()
        print(f"Error clearing strategies: {e}")
        traceback.print_exc() # Added for more detailed error logging
        return None
    finally:
        db.close()

def clear_all_files_and_folders():
    db = SessionLocal()
    try:
        # This executes a "DELETE FROM strategy_files" statement, deleting all rows.
        num_rows_deleted = db.query(StrategyFile).delete()
        db.commit()
        return {"status": "success", "message": f"Successfully deleted {num_rows_deleted} items."}
    except Exception as e:
        db.rollback()
        # In a real app, you would log this error
        print(f"Error clearing strategies: {e}")
        return None
    finally:
        db.close()

def create_multiple_strategy_items(items: list[dict]):
    db = SessionLocal()
    try:
        # Create a list of StrategyFile objects from the dictionaries
        new_items = [StrategyFile(**item) for item in items]
        
        # db.add_all() efficiently stages all the new objects
        db.add_all(new_items)
        
        # A single commit writes all of them to the database
        db.commit()
        
        return {"status": "success", "message": f"Successfully imported {len(new_items)} items."}
    except Exception as e:
        db.rollback() # If any item fails, roll back the entire transaction
        print(f"Error during bulk insert: {e}")
        return None
    finally:
        db.close()



# --- 2. ADD NEW CRUD FUNCTIONS FOR BACKTEST JOBS ---

def create_backtest_job(batch_id: str):
    """
    Creates an initial record for a new backtest job in the database.
    """
    db = SessionLocal()
    try:
        # Create a new job with a 'pending' status
        new_job = BacktestJob(id=batch_id, status="pending")
        db.add(new_job)
        db.commit()
        print(f"--- Created initial DB record for batch_id: {batch_id} ---")
    finally:
        db.close()

def update_job_status(batch_id: str, status: str, log_message: str = None):
    """
    Updates the status of a job and appends a new log message.
    """
    with SessionLocal() as db:
        try:
            job = db.query(BacktestJob).filter(BacktestJob.id == batch_id).first()
            if job:
                job.status = status
                if log_message:
                    # SQLAlchemy's JSON type tracks mutations, so we can append directly.
                    # It's safer to get the list, append, and then re-assign.
                    current_logs = job.logs or []
                    timestamp = datetime.now().strftime('%H:%M:%S.%f')[:-3] # HH:MM:SS.ms
                    current_logs.append(f"[{timestamp}] {log_message}")
                    job.logs = current_logs
                db.commit()
        except Exception as e:
            db.rollback()
            print(f"DB ERROR in update_job_status: {e}")
            raise
        finally:
            db.close()

def fail_job(batch_id: str, error: str):
    """
    Marks a job as 'failed' and stores the error message.
    """
    db = SessionLocal()
    try:
        job = db.query(BacktestJob).filter(BacktestJob.id == batch_id).first()
        if job:
            job.status = "failed"
            job.error_message = error
            db.commit()
    finally:
        db.close()

def save_backtest_results(batch_id: str, results: dict):
    """
    Saves the final, successful result data to a completed job.
    """
    db = SessionLocal()
    try:
        job = db.query(BacktestJob).filter(BacktestJob.id == batch_id).first()
        if job:
            job.status = "completed"
            job.results_data = results
            db.commit()
    finally:
        db.close()

# --- 3. CREATE a function to get the full job details ---
def get_backtest_job(batch_id: str):
    """
    Retrieves the full details of a specific backtest job.
    """
    db = SessionLocal()
    try:
        job = db.query(BacktestJob).filter(BacktestJob.id == batch_id).first()
        if job:
            # Convert the SQLAlchemy object to a dictionary for the API
            return {
                "id": job.id, 
                "status": job.status, 
                "results": job.results_data, 
                "logs": job.logs, 
                "error": job.error_message,
                "created_at": job.created_at
            }
        return None
    finally:
        db.close()
        
def clear_ohlcv_tables():
    """
    Finds and drops all tables in the database whose names start with 'data_'.
    This is used to safely clear the OHLCV cache without touching other tables.
    """
    with engine.connect() as conn:
        # Start a transaction. If any part fails, it will all be rolled back.
        with conn.begin():
            # Query the master table to find all OHLCV data tables
            find_tables_sql = text("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'data_%'")
            
            # The result will be a list of tuples, e.g., [('data_BTCUSDT_15m',), ('data_ETHUSDT_1h',)]
            tables_to_drop = conn.execute(find_tables_sql).fetchall()
            
            if not tables_to_drop:
                return {"status": "success", "message": "No OHLCV data tables found to clear."}
            
            # Loop through the list and execute a DROP TABLE command for each one
            for table_row in tables_to_drop:
                table_name = table_row[0]
                print(f"Dropping table: {table_name}")
                # IMPORTANT: Table names cannot be parameterized in SQL statements.
                # This is safe ONLY because we are getting the names directly from
                # the database's own schema table.
                conn.execute(text(f'DROP TABLE "{table_name}"'))
        
        # The transaction is automatically committed here if everything succeeded
        
    count = len(tables_to_drop)
    return {"status": "success", "message": f"Successfully cleared {count} OHLCV data table(s)."}


# --- CRUD functions for Labeling Templates (Now they will work) ---
def get_all_labeling_templates(db: Session):
    templates_from_db = db.query(LabelingTemplate).all()
    # Convert the list of ORM objects into a dictionary
    return {t.key: {"name": t.name, "description": t.description, "code": t.code, "isDeletable": True} for t in templates_from_db}

def save_labeling_template(db: Session, key: str, name: str, description: str, code: str):
    # Check if template with the same key already exists
    db_template = db.query(LabelingTemplate).filter(LabelingTemplate.key == key).first()
    if db_template:
        # Update existing template
        db_template.name = name
        db_template.description = description
        db_template.code = code
    else:
        # Create new template
        db_template = LabelingTemplate(key=key, name=name, description=description, code=code)
        db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_labeling_template(db: Session, key: str):
    db_template = db.query(LabelingTemplate).filter(LabelingTemplate.key == key).first()
    if db_template:
        db.delete(db_template)
        db.commit()
        return {"status": "success", "message": f"Template {key} deleted."}
    return None


# --- CRUD functions for Feature Engineering Templates ---
def get_all_fe_templates(db: Session):
    templates_from_db = db.query(FeatureEngineeringTemplate).all()
    # Convert the list of ORM objects into a dictionary for the frontend
    return {t.key: {"name": t.name, "description": t.description, "code": t.code, "isDeletable": True} for t in templates_from_db}

def save_fe_template(db: Session, key: str, name: str, description: str, code: str):
    # Check if a template with the same key already exists
    db_template = db.query(FeatureEngineeringTemplate).filter(FeatureEngineeringTemplate.key == key).first()
    if db_template:
        # Update existing template
        db_template.name = name
        db_template.description = description
        db_template.code = code
    else:
        # Create a new template
        db_template = FeatureEngineeringTemplate(key=key, name=name, description=description, code=code)
        db.add(db_template)
    db.commit()
    db.refresh(db_template)
    return db_template

def delete_fe_template(db: Session, key: str):
    db_template = db.query(FeatureEngineeringTemplate).filter(FeatureEngineeringTemplate.key == key).first()
    if db_template:
        db.delete(db_template)
        db.commit()
        return {"status": "success", "message": f"Template {key} deleted."}
    return None

def get_all_backtest_templates(db: Session):
    templates_from_db = db.query(BacktestTemplate).all()
    return {t.key: {"name": t.name, "description": t.description, "code": t.code, "isDeletable": True} for t in templates_from_db}

def save_backtest_template(db: Session, key: str, name: str, description: str, code: str):
    db_template = db.query(BacktestTemplate).filter(BacktestTemplate.key == key).first()
    if db_template:
        db_template.name, db_template.description, db_template.code = name, description, code
    else:
        db_template = BacktestTemplate(key=key, name=name, description=description, code=code)
        db.add(db_template)
    db.commit()
    return db_template

def delete_backtest_template(db: Session, key: str):
    db_template = db.query(BacktestTemplate).filter(BacktestTemplate.key == key).first()
    if db_template:
        db.delete(db_template)
        db.commit()
        return {"status": "success", "message": f"Template {key} deleted."}
    return None